<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Steganography: Hide Text in PNG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #333;
            color: #e0e0e0;
        }
        header {
            background: #23272b;
            padding: 1rem 2rem;
            text-align: center;
            font-size: 2rem;
            letter-spacing: 2px;
            border-bottom: 2px solid #333;
        }
        main {
            max-width: 700px;
            margin: 2rem auto;
            background: #23272b;
            border-radius: 10px;
            box-shadow: 0 2px 8px #0008;
            padding: 2rem;
        }
        h2 {
            margin-top: 0;
            font-size: 1.3rem;
            color: #98FB98;
        }
        .drop-area {
            border: 2px dashed #98FB98;
            border-radius: 8px;
            padding: 1.5em;
            text-align: center;
            margin-bottom: 1.2em;
            background: #181c20;
            transition: border-color 0.2s;
        }
        .drop-area.dragover {
            border-color: #ffd54f;
            background: #23272b;
        }
        .file-info {
            margin: 0.5em 0;
            color: #90caf9;
            font-size: 1em;
        }
        input[type="file"] {
            display: none;
        }
        label.file-label {
            display: inline-block;
            background: #98FB98;
            color: #222;
            padding: 0.6em 1.2em;
            border-radius: 6px;
            cursor: pointer;
            margin: 0.5em 0;
            font-weight: bold;
        }
        .form-group {
            margin-bottom: 1.2em;
        }
        input[type="password"], input[type="text"] {
            width: 100%;
            padding: 0.6em;
            border-radius: 5px;
            border: 1px solid #333;
            background: #181c20;
            color: #e0e0e0;
            font-size: 1em;
        }
        button {
            background: #ffd54f;
            color: #222;
            padding: 0.7em 2em;
            border-radius: 7px;
            border: none;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background 0.2s;
            margin-top: 1em;
        }
        button:disabled {
            background: #888;
            cursor: not-allowed;
        }
        .result {
            margin-top: 2em;
            color: #98FB98;
            font-size: 1.1em;
        }
        @media (max-width: 600px) {
            main { padding: 1em; }
            h2 { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <header>
        Steganography: Hide Text in JPEG
    </header>
    <main>
    <div style="display:flex; gap:1em; margin-bottom:2em;">
        <button id="toggleModeBtn" style="padding:0.6em 1.5em; border-radius:6px; background:#90caf9; color:#222; border:none; cursor:pointer;">
            Switch to Decrypt Mode
        </button>
    </div>
    <div id="hideUI">
        <h2>Step 1: Select or Drag & Drop a JPEG Image</h2>
        <div id="imgDrop" class="drop-area">
            <label class="file-label">
                Choose JPEG
                <input type="file" id="imgInput" accept="image/png">
            </label>
            <div id="imgInfo" class="file-info"></div>
        </div>

        <h2>Step 2: Select or Drag & Drop a Text File</h2>
        <div id="txtDrop" class="drop-area">
            <label class="file-label">
                Choose Text File
                <input type="file" id="txtInput" accept=".txt">
            </label>
            <div id="txtInfo" class="file-info"></div>
        </div>

        <div class="form-group">
            <h2>Step 3: Enter Encryption Key</h2>
            <input type="password" id="keyInput" placeholder="Encryption Key">
        </div>

        <button id="hideBtn" disabled>Hide Text in Image</button>

        <div id="result" class="result"></div>
    </div>
    <div id="decryptUI" style="display:none;">
        <h2>Step 1: Select or Drag & Drop a JPEG Image</h2>
        <div id="decImgDrop" class="drop-area">
            <label class="file-label">
                Choose JPEG
                <input type="file" id="decImgInput" accept="image/png">
            </label>
            <div id="decImgInfo" class="file-info"></div>
        </div>
        <div class="form-group">
            <h2>Step 2: Enter Encryption Key</h2>
            <input type="password" id="decKeyInput" placeholder="Encryption Key">
        </div>
        <button id="decryptBtn" disabled>Extract & Decrypt Text</button>
        <div id="decResult" class="result"></div>
    </div>
</main>

<script>

        // --- Toggle UI ---
        const toggleBtn = document.getElementById('toggleModeBtn');
        const hideUI = document.getElementById('hideUI');
        const decryptUI = document.getElementById('decryptUI');
        let decryptMode = false;
        toggleBtn.addEventListener('click', () => {
        decryptMode = !decryptMode;
            hideUI.style.display = decryptMode ? 'none' : '';
            decryptUI.style.display = decryptMode ? '' : 'none';
            toggleBtn.textContent = decryptMode ? 'Switch to Hide Mode' : 'Switch to Decrypt Mode';
        });

        // --- Drag & Drop Handlers ---
        function setupDropArea(areaId, inputId, infoId, fileType, onFile) {
            const area = document.getElementById(areaId);
            const input = document.getElementById(inputId);
            const info = document.getElementById(infoId);

            area.addEventListener('dragover', e => {
                e.preventDefault();
                area.classList.add('dragover');
            });
            area.addEventListener('dragleave', e => {
                area.classList.remove('dragover');
            });
            area.addEventListener('drop', e => {
                e.preventDefault();
                area.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.match(fileType)) {
                    info.textContent = file.name;
                    onFile(file);
                } else {
                    info.textContent = 'Invalid file type!';
                }
            });
            input.addEventListener('change', e => {
                const file = e.target.files[0];
                if (file && file.type.match(fileType)) {
                    info.textContent = file.name;
                    onFile(file);
                } else {
                    info.textContent = 'Invalid file type!';
                }
            });
        }

        let imgFile = null, txtFile = null, imgDataUrl = null, txtContent = null;

        setupDropArea('imgDrop', 'imgInput', 'imgInfo', /^image\/png$/, file => {
            imgFile = file;
            const reader = new FileReader();
            reader.onload = e => {
                imgDataUrl = e.target.result;
                checkReady();
            };
            reader.readAsDataURL(file);
        });

        setupDropArea('txtDrop', 'txtInput', 'txtInfo', /^text\/plain$/, file => {
            txtFile = file;
            const reader = new FileReader();
            reader.onload = e => {
                txtContent = e.target.result;
                checkReady();
            };
            reader.readAsText(file);
        });

        document.getElementById('keyInput').addEventListener('input', checkReady);

        function checkReady() {
            const key = document.getElementById('keyInput').value;
            document.getElementById('hideBtn').disabled = !(imgDataUrl && txtContent && key);
        }

    // --- XOR Encryption ---
    function encryptText(text, keyStr) {
        const enc = new TextEncoder();
        const textBytes = enc.encode(text);
        const keyBytes = enc.encode(keyStr);
        const out = new Uint8Array(textBytes.length);
        for (let i = 0; i < textBytes.length; i++) {
            out[i] = textBytes[i] ^ keyBytes[i % keyBytes.length];
        }
        return out;
    }

    // --- XOR Decryption (repeating-key XOR, UTF-8) ---
    function decryptText(cipherBytes, keyStr) {
        const keyBytes = new TextEncoder().encode(keyStr);
        const out = new Uint8Array(cipherBytes.length);
        for (let i = 0; i < cipherBytes.length; i++) {
            out[i] = cipherBytes[i] ^ keyBytes[i % keyBytes.length];
        }
        return new TextDecoder().decode(out);
    }

        // --- LSB Steganography ---
        
function bytesConcat(...arrs) {
    const total = arrs.reduce((s, a) => s + a.length, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for (const a of arrs) {
        out.set(a, off);
        off += a.length;
    }
    return out;
}

async function computeHMAC(keyStr, dataBytes) {
    const keyBytes = new TextEncoder().encode(keyStr);
    const cryptoKey = await crypto.subtle.importKey(
        "raw",
        keyBytes,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign", "verify"]
    );
    const sig = await crypto.subtle.sign("HMAC", cryptoKey, dataBytes);
    return new Uint8Array(sig);
}

function hideDataInImage(payloadBytes, callback) {
    const img = new Image();
    img.onload = function() {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const imgData = ctx.getImageData(0, 0, img.width, img.height);
        const pixels = imgData.data;

        // Count usable channels (skip alpha every 4th channel)
        const usableChannels = pixels.length - Math.floor(pixels.length / 4);

        // Max bytes we can store = usableChannels / 8
        const maxBytes = Math.floor(usableChannels / 8);
        if (payloadBytes.length > maxBytes) {
            callback({ error: `Payload too large! Capacity: ${maxBytes} bytes, need: ${payloadBytes.length}` });
            return;
        }

        // Write payload MSB-first into successive RGB LSBs (skip alpha channels)
        let byteIdx = 0, bitIdx = 0;
        let channelIdx = 0;
        function nextChannelIndex() {
            while (channelIdx < pixels.length && (channelIdx % 4) === 3) channelIdx++; // skip alpha
            return channelIdx++;
        }

        while (byteIdx < payloadBytes.length) {
            const b = payloadBytes[byteIdx];
            for (let bit = 7; bit >= 0; bit--) {
                const ch = nextChannelIndex();
                const bitVal = (b >> bit) & 1;
                pixels[ch] = (pixels[ch] & 0xFE) | bitVal;
            }
            byteIdx++;
        }

        ctx.putImageData(imgData, 0, 0);
        canvas.toBlob(blob => {
            callback({ blob });
        }, "image/png", 0.92);
    };
    img.onerror = () => callback({ error: "Failed to load image" });
    img.src = imgDataUrl;
}

// Replace hide button handler: assemble header+ciphertext+HMAC and then hide
document.getElementById('hideBtn').addEventListener('click', async function() {
    const btn = this;
    btn.disabled = true;
    const resultDiv = document.getElementById('result');
    resultDiv.textContent = "Processing...";
    try {
        const key = document.getElementById('keyInput').value;
        const ciphertext = encryptText(txtContent, key); // Uint8Array

        // Build header: magic (4 bytes) + length (4 bytes big-endian)
        const magic = new TextEncoder().encode('STEG');
        const lenBytes = new Uint8Array(4);
        const dataLen = ciphertext.length;
        lenBytes[0] = (dataLen >>> 24) & 0xFF;
        lenBytes[1] = (dataLen >>> 16) & 0xFF;
        lenBytes[2] = (dataLen >>> 8) & 0xFF;
        lenBytes[3] = (dataLen) & 0xFF;

        // Compute HMAC over (magic || length || ciphertext)
        const toMac = bytesConcat(magic, lenBytes, ciphertext);
        const hmac = await computeHMAC(key, toMac); // Uint8Array (SHA-256 -> 32 bytes)

        const payload = bytesConcat(magic, lenBytes, ciphertext, hmac);

        hideDataInImage(payload, result => {
            if (result.error) {
                resultDiv.textContent = result.error;
                btn.disabled = false;
                return;
            }
            const url = URL.createObjectURL(result.blob);
            resultDiv.innerHTML =
                `Success! <a href="${url}" download="stego.png" style="color:#ffd54f;">Download Stego PNG</a> (do not use 'Save image as', always use this link)`;
            btn.disabled = false;
        });
    } catch (e) {
        resultDiv.textContent = "Error: " + e;
        btn.disabled = false;
    }
});


        // --- Decrypt UI Drag & Drop ---
function setupDecDropArea(areaId, inputId, infoId, onFile) {
    const area = document.getElementById(areaId);
    const input = document.getElementById(inputId);
    const info = document.getElementById(infoId);

    area.addEventListener('dragover', e => {
        e.preventDefault();
        area.classList.add('dragover');
    });
    area.addEventListener('dragleave', e => {
        area.classList.remove('dragover');
    });
    area.addEventListener('drop', e => {
        e.preventDefault();
        area.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && file.type.match(/^image\/png$/)) {
            info.textContent = file.name;
            onFile(file);
        } else {
            info.textContent = 'Invalid file type!';
        }
    });
    input.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file && file.type.match(/^image\/png$/)) {
            info.textContent = file.name;
            onFile(file);
        } else {
            info.textContent = 'Invalid file type!';
        }
    });
}

let decImgDataUrl = null;
setupDecDropArea('decImgDrop', 'decImgInput', 'decImgInfo', file => {
    const reader = new FileReader();
    reader.onload = e => {
        decImgDataUrl = e.target.result;
        checkDecReady();
    };
    reader.readAsDataURL(file);
});
document.getElementById('decKeyInput').addEventListener('input', checkDecReady);

function checkDecReady() {
    const key = document.getElementById('decKeyInput').value;
    document.getElementById('decryptBtn').disabled = !(decImgDataUrl && key);
}

// --- Extract Data from Image ---

function extractDataFromImage(imgDataUrl, callback) {
    const img = new Image();
    img.onload = function() {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const imgData = ctx.getImageData(0, 0, img.width, img.height);
        const pixels = imgData.data;

        // Helper to iterate over non-alpha channels
        let channelIdx = 0;
        function nextChannelIndex() {
            while (channelIdx < pixels.length && (channelIdx % 4) === 3) channelIdx++; // skip alpha
            return channelIdx++;
        }

        // First read header (8 bytes = 64 bits)
        const headerBytes = new Uint8Array(8);
        for (let i = 0; i < 8; i++) {
            let val = 0;
            for (let b = 0; b < 8; b++) {
                const ch = nextChannelIndex();
                const bit = pixels[ch] & 1;
                val = (val << 1) | bit;
            }
            headerBytes[i] = val;
        }

        const magic = new TextDecoder().decode(headerBytes.slice(0,4));
        if (magic !== 'STEG') {
            callback(null, `❌ Missing magic header (found "${magic}"). This image may not contain STEG data.`);
            return;
        }
        const dataLen =
            (headerBytes[4] << 24) |
            (headerBytes[5] << 16) |
            (headerBytes[6] << 8) |
            (headerBytes[7]);

        // Validate sizes
        const usableChannels = pixels.length - Math.floor(pixels.length / 4);
        const maxPayloadBytes = Math.floor(usableChannels / 8);
        // payload = header(8) + dataLen + hmac(32)
        const expectedPayloadBytes = 8 + dataLen + 32;
        if (dataLen <= 0 || expectedPayloadBytes > maxPayloadBytes) {
            callback(null, `❌ Invalid or corrupted data length (${dataLen}). This image may not contain hidden data.`);
            return;
        }

        // Now read remainder of payload (dataLen + 32 HMAC)
        const remainderLen = dataLen + 32;
        const remainder = new Uint8Array(remainderLen);
        for (let i = 0; i < remainderLen; i++) {
            let val = 0;
            for (let b = 0; b < 8; b++) {
                const ch = nextChannelIndex();
                const bit = pixels[ch] & 1;
                val = (val << 1) | bit;
            }
            remainder[i] = val;
        }

        // Construct full payload: header + remainder
        const fullPayload = bytesConcat(headerBytes, remainder);
        callback(fullPayload, null);
    };
    img.onerror = () => callback(null, "❌ Failed to load image.");
    img.src = imgDataUrl;
}

// --- XOR Decryption remains the same (uses repeating-key XOR) ---

// --- Decrypt Button Handler ---
document.getElementById('decryptBtn').addEventListener('click', function() {
    const btn = this;
    btn.disabled = true;
    const resultDiv = document.getElementById('decResult');
    resultDiv.textContent = "Processing...";
    try {
        extractDataFromImage(decImgDataUrl, async function(fullPayload, errorMsg) {
            if (errorMsg) {
                resultDiv.textContent = errorMsg;
                btn.disabled = false;
                return;
            }
            if (!fullPayload || fullPayload.length < 8 + 32) {
                resultDiv.textContent = `❌ Extracted payload too short (${fullPayload ? fullPayload.length : 0} bytes).`;
                btn.disabled = false;
                return;
            }

            try {
                // Parse header
                const magic = new TextDecoder().decode(fullPayload.slice(0,4));
                if (magic !== 'STEG') {
                    resultDiv.textContent = `❌ Invalid magic header: ${magic}`;
                    btn.disabled = false;
                    return;
                }
                const dataLen =
                    (fullPayload[4] << 24) |
                    (fullPayload[5] << 16) |
                    (fullPayload[6] << 8) |
                    (fullPayload[7]);

                const ciphertext = fullPayload.slice(8, 8 + dataLen);
                const hmacExtracted = fullPayload.slice(8 + dataLen);

                const key = document.getElementById('decKeyInput').value;
                // compute expected HMAC
                const toMac = bytesConcat(fullPayload.slice(0, 8 + dataLen)); // magic||len||ciphertext
                let hmacExpected;
                try {
                    hmacExpected = await computeHMAC(key, toMac);
                } catch (e) {
                    resultDiv.textContent = "❌ HMAC computation failed: " + e;
                    btn.disabled = false;
                    return;
                }

                // constant-time compare
                if (hmacExtracted.length !== hmacExpected.length) {
                    resultDiv.textContent = `❌ HMAC length mismatch.`;
                    btn.disabled = false;
                    return;
                }
                let diff = 0;
                for (let i = 0; i < hmacExpected.length; i++) diff |= hmacExpected[i] ^ hmacExtracted[i];
                if (diff !== 0) {
                    resultDiv.textContent = "❌ Authentication failed — wrong key or corrupted data.";
                    btn.disabled = false;
                    return;
                }

                // Decrypt ciphertext using repeating-key XOR
                let text;
                try {
                    text = decryptText(ciphertext, key);
                } catch (decryptionError) {
                    resultDiv.textContent = "❌ Decryption error: " + decryptionError;
                    btn.disabled = false;
                    return;
                }

                const blob = new Blob([text], {type: "text/plain"});
                const url = URL.createObjectURL(blob);
                resultDiv.innerHTML =
                    `✅ Success! <a href="${url}" download="extracted.txt" style="color:#ffd54f;">Download Extracted Text</a><br><pre style="margin-top:1em;background:#181c20;padding:1em;border-radius:6px;max-height:300px;overflow:auto;">${text.replace(/</g,"&lt;")}</pre>`;
                btn.disabled = false;
            } catch (e) {
                resultDiv.textContent = "❌ Unexpected error: " + e;
                btn.disabled = false;
            }
        });
    } catch (e) {
        document.getElementById('decResult').textContent = "❌ Error: " + e;
        this.disabled = false;
    }
});
    </script>
</body>
</html>